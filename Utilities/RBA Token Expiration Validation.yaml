- defaultTab: nodes
  description: ''
  executionEnabled: true
  group: Utilities
  id: dab86943-1f92-4409-8ed3-b26e959c59f7
  loglevel: INFO
  maxMultipleExecutions: '10'
  multipleExecutions: true
  name: RBA Token Expiration Validation
  nodeFilterEditable: false
  nodefilters:
    dispatch:
      excludePrecedence: true
      keepgoing: false
      rankOrder: ascending
      successOnEmptyNodeFilter: false
      threadcount: '1'
    filter: .*runner
  nodesSelectedByDefault: true
  options:
  - description: expirationdays
    label: expirationdays
    name: expirationdays
    required: true
    value: '30'
    values:
    - '1'
    - '5'
    - '15'
    - '30'
    - '40'
    - '50'
    - '60'
    - '70'
    valuesListDelimiter: ','
  - hidden: true
    name: api-token
    secure: true
    storagePath: keys/rba/bdias-rba-token
    valueExposed: true
  - hidden: true
    name: pd-orchestration-key
    secure: true
    storagePath: keys/pagerduty/pdt-bdias-global-orchestration-key
    valueExposed: true
  - name: rba-url
    value: bdias.myrundeck.com
  plugins:
    ExecutionLifecycle:
      Send Incident Output to Pagerduty: {}
  runnerSelector:
    filter: OREGON_AWS_NODE
    runnerFilterMode: TAGS
    runnerFilterType: TAG_FILTER_AND
  scheduleEnabled: true
  schedules:
  - jobParams: -expirationdays 5
    name: RBA Tokens Expiration Date
  sequence:
    commands:
    - autoSecureInput: 'false'
      passSecureInput: 'false'
      plugins:
        LogFilter:
        - config:
            invalidKeyPattern: \s|\$|\{|\}|\\
            logData: 'true'
            name: TOKEN_ALERT
            regex: ^RUNDECK:DATA:\s*([^\s]+?)\s*=\s*(.+)$
            replaceFilteredResult: 'false'
          type: key-value-data
        - config:
            captureMultipleKeysValues: 'true'
            hideOutput: 'false'
            logData: 'true'
            name: tokens
            regex: (?s)(?<=---START-TOKENS---\s*).*?(?=\s*---END-TOKENS---)
          type: key-value-data-multilines
        - config:
            filterName: RBA Expired Tokens
            logOutputSettings: All
            stepStatus: Any
          type: pagerduty-incident-output-capture
      script: |-
        #!/bin/bash
        # Script: Token Expiration Checker with Alert Variable (JSON version)
        # This script connects to the Rundeck tokens endpoint, retrieves the token information,
        # and evaluates the expiration date of each one.
        #
        # If a token will expire within the next 30 days (or has already expired), it will be displayed in a table with:
        #   - Creator
        #   - Name
        #   - Expiration (processed date)
        #   - Status (expired or the number of days remaining until expiration)
        #
        # Additionally, the TOKEN_ALERT variable is assigned the value 'ALERT' if at least one token
        # is nearing expiration or has already expired, or 'OK' otherwise.
        #
        # Configuration: Adjust the values of API_TOKEN and RUNDECK_URL to match your environment.

        # Configuration
        API_TOKEN="@option.api-token@"
        RUNDECK_URL="https://@option.rba-url@/api/52/tokens"
        THRESHOLD_DAYS=30

        echo "Querying Rundeck API: $RUNDECK_URL" >&2

        # Check if jq is installed
        if ! command -v jq &> /dev/null; then
            echo "Error: jq is not installed. Please install jq to parse JSON responses." >&2
            exit 1
        fi

        # Connect to the endpoint (uses --fail for HTTP errors)
        response=$(curl -s -L --fail -H "X-Rundeck-Auth-Token: $API_TOKEN" "$RUNDECK_URL")
        if [ $? -ne 0 ]; then
            echo "Error: Unable to connect to the endpoint. Please check the URL, the token, or your connectivity." >&2
            exit 1
        fi

        if [ -z "$response" ]; then
            echo "Error: No response received from the API." >&2
            exit 1
        fi

        # Verify that the response is valid JSON
        if ! echo "$response" | jq empty 2>/dev/null; then
            echo "Error: The response is not valid JSON. Response: $response" >&2
            exit 1
        fi

        # Check if the response is an array
        if ! echo "$response" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "Error: The response is not a JSON array as expected." >&2
            exit 1
        fi

        # Function to parse ISO 8601 dates into Unix timestamp.
        if [[ "$(uname)" == "Darwin" ]]; then
            parse_date() { date -j -f "%Y-%m-%dT%H:%M:%SZ" "$1" +%s 2>/dev/null; }
        else
            parse_date() { date -d "$1" +%s 2>/dev/null; }
        fi

        now_ts=$(date +%s)
        expiringCount=0

        # Process each token from the JSON array.
        echo "$response" | jq -c '.[]' | while IFS= read -r token; do
            # Extract fields from the JSON token object.
            creator=$(echo "$token" | jq -r '.creator // "N/A"')
            token_id=$(echo "$token" | jq -r '.id // "N/A"')
            name=$(echo "$token" | jq -r '.name // "N/A"')
            expiration=$(echo "$token" | jq -r '.expiration // "null"')
            expired_flag=$(echo "$token" | jq -r '.expired // false')

            # Skip tokens without a valid expiration date.
            if [ -z "$expiration" ] || [ "$expiration" == "null" ]; then
                continue
            fi

            # Parse the ISO 8601 date format (e.g., "2017-03-25T21:16:50Z")
            exp_ts=$(parse_date "$expiration")
            if [ -z "$exp_ts" ]; then
                echo "Warning: Unable to parse the date for token '$name' with: $expiration" >&2
                continue
            fi

            diff_seconds=$(( exp_ts - now_ts ))
            diff_days=$(( diff_seconds / 86400 ))

            # If the token has already expired or will expire within THRESHOLD_DAYS days.
            if [ $diff_seconds -le $(( THRESHOLD_DAYS * 86400 )) ]; then
                if [ $diff_seconds -lt 0 ]; then
                    status="Expired"
                else
                    status="Expires in ${diff_days} day(s)"
                fi
                # Append the row to a temporary file for later processing.
                echo "$token_id|$creator|$name|$expiration|$status"
                # Increase a counter; using a temp file because we're in a subshell.
                echo "increment" >> /tmp/token_check_count.txt
            fi
        done > /tmp/token_rows.txt

        # Combine the increments from the subshell.
        if [ -f /tmp/token_check_count.txt ]; then
            expiringCount=$(grep -c "increment" /tmp/token_check_count.txt)
            rm /tmp/token_check_count.txt
        fi

        # Print marker for regex
        echo "---START-TOKENS---"

        # Print the table if tokens are found.
        if [ -s /tmp/token_rows.txt ]; then
            {
              echo "ID|Creator|Name|Expiration|Status"
              cat /tmp/token_rows.txt
            } | column -t -s '|'
            rm /tmp/token_rows.txt
        else
            echo "There are no tokens expiring within the next $THRESHOLD_DAYS days."
        fi

        # Print marker for regex
        echo "---END-TOKENS---"

        # Set the TOKEN_ALERT variable based on the existence of tokens nearing expiration.
        if [ $expiringCount -gt 0 ]; then
            TOKEN_ALERT="ALERT"
        else
            TOKEN_ALERT="OK"
        fi

        # Print the final result in a format compatible with Rundeck.
        echo "RUNDECK:DATA: TOKEN_ALERT=$TOKEN_ALERT"
    - configuration:
        export: TOKEN_ALERT
        group: export
        value: ${data.TOKEN_ALERT*}
      nodeStep: false
      type: export-var
    - exec: echo ${export.TOKEN_ALERT}
    - autoSecureInput: 'false'
      passSecureInput: 'false'
      script: |2
                # This script sends an alert to PagerDuty using the Events API v2.
                # It reads the expiration threshold from the job option RD_OPTION_EXPIRATIONDAYS and
                # constructs an alert message notifying that there are tokens expiring within the threshold,
                # without listing token names.
                #
                # This step should run only when the Ruleset condition triggers it (i.e. when TOKEN_ALERT equals "ALERT").

                # PagerDuty Routing Key (your integration/routing key)
                PAGERDUTY_ROUTING_KEY="@option.pd-orchestration-key@"

                # Get the expiration threshold from the job option; default to 30 if not provided.
                THRESHOLD_DAYS="${RD_OPTION_EXPIRATIONDAYS}"
                if [ -z "$THRESHOLD_DAYS" ]; then
                  THRESHOLD_DAYS=30
                fi

                # Construct the custom alert message using the dynamic threshold.
                alert_message="There are Tokens that are going to expire in the following ${THRESHOLD_DAYS} day(s), please check your RBA instance. Go to Profile Icon then select Profile menu and check User API Tokens section for more details"
                tokens_list=""

                echo "TOKEN_ALERT condition met. Triggering PagerDuty alert..."
                echo "Custom alert message: ${alert_message}"

                # Send alert to PagerDuty via the Events API v2.
                response=$(curl -s -X POST -H "Content-Type: application/json" \
                    -d '{
                          "routing_key": "'"${PAGERDUTY_ROUTING_KEY}"'",
                          "event_action": "trigger",
                          "dedup_key": "@job.id@",
                          "payload": {
                              "summary": "Alert: Tokens near expiration in Rundeck",
                              "source": "Runbook Automation",
                              "severity": "warning",
                              "custom_details": {
                                  "info": "'"${alert_message}"'"
                              }
                          }
                        }' \
                    "https://events.pagerduty.com/v2/enqueue")

                echo "PagerDuty response: $response"
    keepgoing: false
    pluginConfig:
      WorkflowStrategy:
        ruleset:
          rules: |
            [*] run-in-sequence
            [4] if:export.TOKEN_ALERT==ALERT
    strategy: ruleset
  tags: token
  user: admin
  uuid: dab86943-1f92-4409-8ed3-b26e959c59f7

